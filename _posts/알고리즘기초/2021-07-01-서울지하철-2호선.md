---
layout: post
title :  "서울지하철 2호선"
subtitle :  "서울지하철"
comments: 알고리즘기초 그래프 BFS DFS
categories: 알고리즘
tags: acmicpc
---

### 서울지하철 2호선 문제 풀이
#### 문제 : https://www.acmicpc.net/problem/16947

- 각 역과 순환선 사이 거리 구하는 문제
-  역 개수 :  3 <= N <= 3000
- 역과 역을 연결하는 구간 정보 (예: 1번역 -> 3번역 :  1 3)

순환선 = 사이클
N개 정점 N개 간선 -> 사이클은 한개
1에서 탐색 시작.. .  이전에 방문했던 칸과 다른칸으로 계속 이동했을 때 
이미 방문한 칸 도착했다면 사이클을 방문할 수 있음.
```
1 - 2 - 5   12
|       |    |
4 - 3 - 7 - 10 - 11 
|   | 
9   6 - 8
```
A. 1에서 시작 :  1 - 2 - 5 - 7 - 10 - 12(no way) - 10(back) - 11(no way) - 10(back) - 7(back) - 3 - 4 - 1(arrive)
고로, 아래와 같이 사이클 생성
```
1 - 2 - 5 
|       | 
4 - 3 - 7 
```
B. 1에서 시작 :  1 - 2 - 5 - 7 - 3 - 4 - 1 =>  pop4 pop3 pop7 pop5 pop2 pop2
마찬가지로 A처럼 사이클 생성

C. 8에서 시작 : 8 - 6 - 3 - 4 - 1 - 2 - 5 - 7 - 3발견 - pop7 - pop5 - pop2 - pop1 - pop4 - pop3 이후 6과 8도 사이클 일부? -> NO!

- 어떤 정점이 사이클에 포함되는지 알아야 한다!

D. 8에서 시작 : 8 - 6 - 3 - 7 - 5 - 2 - 1 - 4 - 9방문( POP) - 3발견 (이미 방문한 정점이므로 사이클의 시작) 
   -- 사이클의 시작정점 4에 3을 리턴(4는 3이 아니므로 사이클) - 마찬가지로 1도 사이클 2도 사이클 5도 사이클 7도 사이클
   -- 3리턴해서 3 사이클! 이후 부터는 사이클이 아님 (6과 8) -> 사이클이 아닐 때는 음수  리턴하는 방법 사용


```c++
// DFS로 순환선 구하기 
// p -> x -> y : p에서 x를 가고 x에서 갈 수 있는 y를 찾아야 함
int go(int x, int p) {
    // -2: 사이클 찾음, 포함되지 않음,  -1 : 사이클 못 찾음,  0~N-1 :  사이클 음음, 시작정점 인덱스 리턴
    if(check[x] == 1) return x; // 또 받문하면 사이클이라고 할 수 있으니 사이클의 시작인덱스인 x를 리턴
    check[x] = 1;
    for(int y : a[x]) {
        if (y == p) continue; //이전 정점과 같으면 건너뛴다
        int res = go(y, x); // 현재 정점이 y, 이전 정점이 x
        if (res == -2) return -2;
        if (res >= 0) { //사이클 포함
          check[x] = 2;  // 1은 그냥 방문, 2는 방문했고 사이클에 포함된거
          if (x == res) return -2; else return res;  // 정점이 사이클의 시작점과 같으면 지금부터 리턴하는 정점은 사이클에 포함하면 안되므로 -2, 아니면  사이클의 시작 정점 리턴
        }
    }
    return -1;
}
```

- 각 정점이 얼마나 떨어져 있는지 구하려면 거리 : 모든 가중치가 1이기 때문에 BFS알고리즘 사용함
- 거리를 구하는 방법 :  u → v 이동한다 가정했을 때 v의 거리는 u+1 즉, dist[v] = dist[u]+1



```C++
go(0, -1); //dfs 호출

queue<int> q;
// 정점번호 
for(int i=0; i<n; i++) {
    if(check[i] == 2) { //순환선 구할 때,  2는 사이클을 의미한다했으므로
      dist[i] = 0; // 시작점의 거리는 0이므로 
      q.push(i); //큐의 시작점
    } else 함
      dist[i] = -1; // 아직 구하지 못함
    }
}
// BFS로 모든 정점 거리 구함.  -1인 경우(간적 없다면) 방문하고 거리 업데이트. 
while(!q.empty()) {
    int x = q.front(); q.pop();
    for(int y : a[x]) {
        if(dist[y] == -1) {
            q.push(v);
            dist[y] = dist[x] + 1;
        }
    }
}
for(int i=0; i<n; i++) {
  cout << dist[i] << ' ';
}
cout << '\n';
return 0;
```

